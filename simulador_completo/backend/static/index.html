<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador x86-64 | Compiladores UTEC</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: system-ui, sans-serif; }
        .mono { font-family: 'Menlo', 'Monaco', 'Consolas', monospace; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
    </style>
</head>
<body class="bg-slate-900">
    <div id="root"></div>
    <script type="text/babel">
const { useState, useEffect, useRef } = React;

// Detecta autom√°ticamente el puerto del servidor
const API = window.location.origin;

// Estado inicial del simulador
const initState = () => ({
    regs: { rax:0, rbx:0, rcx:0, rdx:0, rsi:0, rdi:0, rbp:0, rsp:496, flags:{ZF:0,SF:0} },
    stack: Array(32).fill(0),
    mem: {},
    out: [],
    done: false,
    line: 0,
    hist: []
});

// Parser de operandos x86
const parseOp = (s, regs, mem) => {
    if (!s) return {v:0, t:'imm'};
    s = s.replace(',','').trim();
    if (s[0] === '$') return {v: parseInt(s.slice(1))||0, t:'imm'};
    if (s[0] === '%') {
        let r = s.slice(1).toLowerCase();
        const m = {eax:'rax',ebx:'rbx',ecx:'rcx',edx:'rdx',esi:'rsi',edi:'rdi',ebp:'rbp',esp:'rsp'};
        r = m[r] || r;
        return {v: regs[r]||0, t:'reg', r};
    }
    const match = s.match(/(-?\d+)?\(%(\w+)\)/);
    if (match) {
        let base = match[2].toLowerCase();
        if (base === 'ebp') base = 'rbp';
        if (base === 'esp') base = 'rsp';
        const addr = (regs[base]||0) + (parseInt(match[1])||0);
        return {v: mem[addr]||0, t:'mem', addr};
    }
    return {v:s, t:'lbl'};
};

// Ejecutar una instrucci√≥n
const exec = (instr, st, lbls) => {
    const ns = JSON.parse(JSON.stringify(st));
    ns.hist = [...st.hist, JSON.parse(JSON.stringify(st))].slice(-50);
    
    const ln = instr.trim();
    if (!ln || ln[0]==='#' || ln[0]==='.' || ln.slice(-1)===':') { ns.line++; return ns; }
    
    const p = ln.split(/\s+/);
    const op = p[0].toLowerCase();
    const g = (x) => parseOp(x, ns.regs, ns.mem);
    
    switch(op) {
        case 'pushq': {
            const src = g(p[1]);
            ns.regs.rsp -= 8;
            ns.mem[ns.regs.rsp] = src.v;
            const i = Math.floor((512-ns.regs.rsp)/8);
            if (i>=0 && i<32) ns.stack[i] = src.v;
            break;
        }
        case 'popq': {
            const i = Math.floor((512-ns.regs.rsp)/8);
            const v = (i>=0 && i<32) ? ns.stack[i] : 0;
            const dst = g(p[1]);
            if (dst.t==='reg') ns.regs[dst.r] = v;
            ns.regs.rsp += 8;
            break;
        }
        case 'movq': case 'movl': {
            const src = g(p[1]), dst = g(p[2]);
            if (dst.t==='reg') ns.regs[dst.r] = src.v;
            else if (dst.t==='mem') ns.mem[dst.addr] = src.v;
            break;
        }
        case 'leaq': {
            const m = p[1]?.match(/(-?\d+)?\(%(\w+)\)/);
            if (m) {
                let base = m[2].toLowerCase();
                if (base==='ebp') base='rbp'; if (base==='esp') base='rsp';
                const addr = (ns.regs[base]||0) + (parseInt(m[1])||0);
                const dst = g(p[2]);
                if (dst.t==='reg') ns.regs[dst.r] = addr;
            }
            break;
        }
        case 'addq': case 'addl': {
            const src = g(p[1]), dst = g(p[2]);
            if (dst.t==='reg') ns.regs[dst.r] += src.v;
            break;
        }
        case 'subq': case 'subl': {
            const src = g(p[1]), dst = g(p[2]);
            if (dst.t==='reg') ns.regs[dst.r] -= src.v;
            break;
        }
        case 'imulq': case 'imull': {
            const src = g(p[1]), dst = g(p[2]);
            if (dst.t==='reg') ns.regs[dst.r] *= src.v;
            break;
        }
        case 'incq': case 'incl': {
            const dst = g(p[1]);
            if (dst.t==='reg') ns.regs[dst.r]++;
            break;
        }
        case 'decq': case 'decl': {
            const dst = g(p[1]);
            if (dst.t==='reg') ns.regs[dst.r]--;
            break;
        }
        case 'shlq': case 'shll': {
            const src = g(p[1]), dst = g(p[2]);
            if (dst.t==='reg') ns.regs[dst.r] <<= src.v;
            break;
        }
        case 'shrq': case 'shrl': {
            const src = g(p[1]), dst = g(p[2]);
            if (dst.t==='reg') ns.regs[dst.r] >>= src.v;
            break;
        }
        case 'negq': case 'negl': {
            const dst = g(p[1]);
            if (dst.t==='reg') ns.regs[dst.r] = -ns.regs[dst.r];
            break;
        }
        case 'cmpq': case 'cmpl': {
            const src = g(p[1]), dst = g(p[2]);
            const a = dst.t==='reg' ? ns.regs[dst.r] : dst.v;
            const r = a - src.v;
            ns.regs.flags.ZF = r===0 ? 1 : 0;
            ns.regs.flags.SF = r<0 ? 1 : 0;
            break;
        }
        case 'testq': case 'testl': {
            const src = g(p[1]), dst = g(p[2]);
            const r = src.v & (dst.t==='reg' ? ns.regs[dst.r] : dst.v);
            ns.regs.flags.ZF = r===0 ? 1 : 0;
            ns.regs.flags.SF = r<0 ? 1 : 0;
            break;
        }
        case 'je': if (ns.regs.flags.ZF && lbls[p[1]]!==undefined) { ns.line=lbls[p[1]]; return ns; } break;
        case 'jne': if (!ns.regs.flags.ZF && lbls[p[1]]!==undefined) { ns.line=lbls[p[1]]; return ns; } break;
        case 'jl': if (ns.regs.flags.SF && lbls[p[1]]!==undefined) { ns.line=lbls[p[1]]; return ns; } break;
        case 'jle': if ((ns.regs.flags.SF || ns.regs.flags.ZF) && lbls[p[1]]!==undefined) { ns.line=lbls[p[1]]; return ns; } break;
        case 'jg': if (!ns.regs.flags.SF && !ns.regs.flags.ZF && lbls[p[1]]!==undefined) { ns.line=lbls[p[1]]; return ns; } break;
        case 'jge': if (!ns.regs.flags.SF && lbls[p[1]]!==undefined) { ns.line=lbls[p[1]]; return ns; } break;
        case 'jmp': if (lbls[p[1]]!==undefined) { ns.line=lbls[p[1]]; return ns; } break;
        case 'call': {
            const fn = p[1]?.replace('@PLT','');
            if (fn==='printf') ns.out.push(String(ns.regs.rsi));
            break;
        }
        case 'leave': {
            ns.regs.rsp = ns.regs.rbp;
            const i = Math.floor((512-ns.regs.rsp)/8);
            ns.regs.rbp = (i>=0 && i<32) ? ns.stack[i] : 0;
            ns.regs.rsp += 8;
            break;
        }
        case 'ret': ns.done = true; break;
        case 'cqto': case 'cdq': break;
        case 'idivq': {
            const src = g(p[1]);
            if (src.v) {
                const d = ns.regs.rax;
                ns.regs.rax = Math.floor(d / src.v);
                ns.regs.rdx = d % src.v;
            }
            break;
        }
    }
    ns.line++;
    return ns;
};

// Componente principal
const App = () => {
    const [rust, setRust] = useState(`fn main() {
    let mut a: i32 = 5;
    let mut b: i32 = 10;
    let mut c: i32 = a + b;
    println!("{}", c);
}`);
    const [asm, setAsm] = useState('');
    const [loading, setLoading] = useState(false);
    const [err, setErr] = useState('');
    const [st, setSt] = useState(initState());
    const [lbls, setLbls] = useState({});
    const [lines, setLines] = useState([]);
    const [running, setRunning] = useState(false);
    const [speed, setSpeed] = useState(200);
    const runRef = useRef(false);

    const parse = (code) => {
        const ls = code.split('\n');
        const lb = {};
        let main = 0;
        ls.forEach((l,i) => { const t=l.trim(); if(t.slice(-1)===':') { lb[t.slice(0,-1)]=i; if(t==='main:') main=i; }});
        setLbls(lb);
        setLines(ls);
        const s = initState();
        s.line = main;
        s.regs.rbp = 512;
        s.regs.rsp = 504;
        setSt(s);
        runRef.current = false;
        setRunning(false);
    };

    const compile = async () => {
        setLoading(true);
        setErr('');
        try {
            const res = await fetch(`${API}/api/compile`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({code: rust})
            });
            const data = await res.json();
            if (data.success) {
                setAsm(data.assembly);
                parse(data.assembly);
            } else {
                setErr(data.error || 'Error');
            }
        } catch(e) {
            setErr('No se pudo conectar al servidor. ¬øEst√° corriendo server.py?');
        }
        setLoading(false);
    };

    const step = () => {
        if (st.done || st.line >= lines.length) return;
        setSt(exec(lines[st.line], st, lbls));
    };

    const run = () => {
        if (running) { runRef.current=false; setRunning(false); return; }
        runRef.current = true;
        setRunning(true);
        const go = () => {
            if (!runRef.current) return;
            setSt(prev => {
                if (prev.done || prev.line >= lines.length) { runRef.current=false; setRunning(false); return prev; }
                const next = exec(lines[prev.line], prev, lbls);
                if (!next.done && runRef.current) setTimeout(go, speed);
                else { runRef.current=false; setRunning(false); }
                return next;
            });
        };
        setTimeout(go, 50);
    };

    const reset = () => { runRef.current=false; setRunning(false); if(asm) parse(asm); };
    const back = () => { if(st.hist.length) { const p=st.hist.slice(-1)[0]; p.hist=st.hist.slice(0,-1); setSt(p); }};

    return (
        <div className="min-h-screen bg-slate-900 p-4">
            <div className="max-w-6xl mx-auto">
                <h1 className="text-2xl font-bold text-white text-center mb-1">ü¶Ä Compilador Rust ‚Üí x86-64 ‚öôÔ∏è</h1>
                <p className="text-slate-500 text-center text-sm mb-4">Simulador Interactivo | CS3402 Compiladores - UTEC</p>
                
                {err && <div className="bg-red-900/50 border border-red-500 text-red-200 p-3 rounded-lg mb-4 flex justify-between">
                    <span>{err}</span>
                    <button onClick={()=>setErr('')} className="text-red-400 hover:text-white">‚úï</button>
                </div>}
                
                <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 mb-4">
                    {/* Editor Rust */}
                    <div className="bg-slate-800 rounded-xl p-4">
                        <div className="flex justify-between items-center mb-2">
                            <span className="text-orange-400 font-bold">ü¶Ä C√≥digo Rust</span>
                            <button onClick={compile} disabled={loading} 
                                className="px-4 py-2 bg-orange-500 hover:bg-orange-600 disabled:bg-slate-600 text-white rounded-lg font-bold text-sm">
                                {loading ? '‚è≥...' : '‚ö° Compilar'}
                            </button>
                        </div>
                        <textarea value={rust} onChange={e=>setRust(e.target.value)} spellCheck={false}
                            className="w-full h-56 bg-slate-900 text-amber-100 mono text-sm p-3 rounded-lg border border-slate-700 focus:border-orange-500 focus:outline-none resize-none" />
                    </div>
                    
                    {/* Assembly */}
                    <div className="bg-slate-800 rounded-xl p-4">
                        <span className="text-cyan-400 font-bold">üìù Assembly x86-64</span>
                        <div className="h-56 mt-2 overflow-auto bg-slate-900 rounded-lg mono text-sm">
                            {asm ? asm.split('\n').map((l,i) => (
                                <div key={i} className={`px-3 py-0.5 flex ${i===st.line ? 'bg-amber-500 text-black font-bold' : l.trim()[0]==='#' ? 'text-green-500' : l.trim().slice(-1)===':' ? 'text-purple-400' : l.trim()[0]==='.' ? 'text-slate-600' : 'text-slate-300'}`}>
                                    <span className="w-6 text-right mr-2 text-slate-600 select-none">{i+1}</span>
                                    <span className="flex-1">{l}</span>
                                    {i===st.line && <span className="text-red-600">‚óÑ</span>}
                                </div>
                            )) : <div className="p-4 text-slate-600 italic">Escribe c√≥digo Rust y presiona Compilar...</div>}
                        </div>
                    </div>
                </div>
                
                {asm && <>
                    {/* Controles */}
                    <div className="bg-slate-800 rounded-xl p-3 mb-4 flex flex-wrap items-center gap-2">
                        <button onClick={back} disabled={!st.hist.length||running} className="px-3 py-2 bg-slate-600 hover:bg-slate-500 disabled:opacity-50 text-white rounded-lg font-bold text-sm">‚óÄ Atr√°s</button>
                        <button onClick={step} disabled={st.done||running} className="px-4 py-2 bg-blue-600 hover:bg-blue-500 disabled:opacity-50 text-white rounded-lg font-bold text-sm">‚ñ∂ Paso</button>
                        <button onClick={run} disabled={st.done} className={`px-4 py-2 ${running?'bg-red-600':'bg-green-600'} hover:opacity-90 disabled:opacity-50 text-white rounded-lg font-bold text-sm`}>{running?'‚è∏ Pausa':'‚è© Run'}</button>
                        <button onClick={reset} className="px-3 py-2 bg-amber-600 hover:bg-amber-500 text-white rounded-lg font-bold text-sm">üîÑ Reset</button>
                        <div className="flex items-center gap-2 ml-2">
                            <span className="text-slate-400 text-xs">Velocidad:</span>
                            <input type="range" min="50" max="500" value={550-speed} onChange={e=>setSpeed(550-+e.target.value)} className="w-16 accent-blue-500" />
                        </div>
                        {st.done && <span className="ml-auto px-3 py-1 bg-green-700 text-white rounded-lg text-sm">‚úì Completado</span>}
                    </div>
                    
                    {/* Paneles de estado */}
                    <div className="grid grid-cols-2 lg:grid-cols-4 gap-4">
                        {/* Registros */}
                        <div className="bg-slate-800 rounded-xl p-3">
                            <div className="text-green-400 font-bold text-sm mb-2">üìä Registros</div>
                            <div className="grid grid-cols-2 gap-1 mono text-xs">
                                {['rax','rbx','rcx','rdx','rsi','rdi','rbp','rsp'].map(r=>(
                                    <div key={r} className="flex justify-between bg-slate-900 px-2 py-1 rounded">
                                        <span className="text-blue-400">%{r}</span>
                                        <span className="text-yellow-300">{st.regs[r]}</span>
                                    </div>
                                ))}
                            </div>
                            <div className="flex gap-1 mt-2">
                                <span className={`px-2 py-0.5 rounded text-xs ${st.regs.flags.ZF?'bg-green-700':'bg-slate-700'} text-white`}>ZF={st.regs.flags.ZF}</span>
                                <span className={`px-2 py-0.5 rounded text-xs ${st.regs.flags.SF?'bg-red-700':'bg-slate-700'} text-white`}>SF={st.regs.flags.SF}</span>
                            </div>
                        </div>
                        
                        {/* Pila */}
                        <div className="bg-slate-800 rounded-xl p-3">
                            <div className="text-purple-400 font-bold text-sm mb-2">üìö Pila</div>
                            <div className="space-y-0.5 mono text-xs max-h-36 overflow-auto">
                                {st.stack.slice(0,12).map((v,i)=>{
                                    const top = Math.floor((512-st.regs.rsp)/8);
                                    return <div key={i} className={`flex justify-between px-2 py-0.5 rounded ${i===top?'bg-purple-600 text-white':i<top?'bg-slate-700':'bg-slate-900 text-slate-600'}`}>
                                        <span>[{i}]</span><span>{v}</span>{i===top&&<span className="text-amber-300 text-xs">‚óÑ</span>}
                                    </div>;
                                })}
                            </div>
                        </div>
                        
                        {/* Variables */}
                        <div className="bg-slate-800 rounded-xl p-3">
                            <div className="text-orange-400 font-bold text-sm mb-2">üíæ Variables</div>
                            <div className="space-y-0.5 mono text-xs max-h-36 overflow-auto">
                                {Object.entries(st.mem).filter(([a])=>+a>=st.regs.rbp-64&&+a<=st.regs.rbp).sort((a,b)=>+b[0]-+a[0]).map(([a,v])=>(
                                    <div key={a} className="flex justify-between px-2 py-0.5 bg-slate-900 rounded">
                                        <span className="text-slate-500">{+a-st.regs.rbp}(%rbp)</span>
                                        <span className="text-cyan-300">{v}</span>
                                    </div>
                                ))}
                                {!Object.keys(st.mem).length && <div className="text-slate-600 italic py-2">Sin variables</div>}
                            </div>
                        </div>
                        
                        {/* Salida */}
                        <div className="bg-slate-800 rounded-xl p-3">
                            <div className="text-green-400 font-bold text-sm mb-2">üñ•Ô∏è Salida</div>
                            <div className="bg-black rounded-lg p-2 mono text-sm min-h-[80px] max-h-36 overflow-auto">
                                {st.out.length ? st.out.map((l,i)=><div key={i} className="text-green-400">{l}</div>) : <span className="text-slate-700">...</span>}
                            </div>
                        </div>
                    </div>
                </>}
                
                <div className="text-center text-slate-600 text-xs mt-4">
                    Optimizaciones: <span className="text-green-500">DAG</span> (subexpresiones) | <span className="text-blue-500">Peephole</span> (incq, shlq)
                </div>
            </div>
        </div>
    );
};

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
